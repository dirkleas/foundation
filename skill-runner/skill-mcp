#!/usr/bin/env -S uv run --quiet --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "claude-agent-sdk>=0.1.38",
#     "pyyaml>=6.0",
#     "pydantic>=2.0",
#     "mcp>=1.0.0",
# ]
# ///
"""MCP Server for skill execution.

Add to Claude Code settings:
{
  "mcpServers": {
    "skill-runner": {
      "command": "/path/to/skill-mcp"
    }
  }
}
"""

from __future__ import annotations

import asyncio
import logging
import subprocess
from pathlib import Path
from typing import Any

import yaml
from claude_agent_sdk import ClaudeAgentOptions, query
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import TextContent, Tool
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


def _patch_sdk_message_parser() -> None:
    """Patch SDK to gracefully handle unknown message types (e.g. rate_limit_event)."""
    import claude_agent_sdk._internal.message_parser as mp
    import claude_agent_sdk._internal.client as internal_client
    from claude_agent_sdk.types import SystemMessage

    if getattr(mp.parse_message, "_patched", False):
        return

    _original = mp.parse_message

    def _safe_parse_message(data):
        try:
            return _original(data)
        except Exception:
            msg_type = data.get("type", "unknown") if isinstance(data, dict) else "unknown"
            logger.debug("SDK: unrecognized message type '%s', wrapping as SystemMessage", msg_type)
            return SystemMessage(subtype=msg_type, data=data if isinstance(data, dict) else {})

    _safe_parse_message._patched = True  # type: ignore[attr-defined]
    mp.parse_message = _safe_parse_message
    internal_client.parse_message = _safe_parse_message


_patch_sdk_message_parser()


# === Schema ===


class SkillInput(BaseModel):
    command: str | None = None
    description: str = ""
    required: bool = True


class SkillOutput(BaseModel):
    format: str = "text"


class Skill(BaseModel):
    name: str
    description: str = ""
    inputs: dict[str, SkillInput] = Field(default_factory=dict)
    output: SkillOutput = Field(default_factory=SkillOutput)
    prompt: str

    def render_prompt(self, inputs: dict[str, str]) -> str:
        result = self.prompt
        for key, value in inputs.items():
            result = result.replace(f"{{{{{key}}}}}", value)
        return result


def parse_skill(content: str, name: str = "unknown") -> Skill:
    if content.startswith("---"):
        parts = content.split("---", 2)
        if len(parts) >= 3:
            frontmatter = parts[1].strip()
            body = parts[2].strip()
        else:
            frontmatter = ""
            body = content
    else:
        frontmatter = ""
        body = content

    meta = yaml.safe_load(frontmatter) if frontmatter else {}
    meta = meta or {}

    raw_inputs = meta.get("inputs", {})
    inputs = {}
    for inp_name, inp_def in raw_inputs.items():
        if isinstance(inp_def, dict):
            inputs[inp_name] = SkillInput(**inp_def)
        else:
            inputs[inp_name] = SkillInput(description=str(inp_def))

    raw_output = meta.get("output", {})
    if isinstance(raw_output, dict):
        output = SkillOutput(**raw_output)
    else:
        output = SkillOutput(format=str(raw_output) if raw_output else "text")

    return Skill(
        name=meta.get("name", name),
        description=meta.get("description", ""),
        inputs=inputs,
        output=output,
        prompt=body,
    )


def load_skill(name: str) -> Skill:
    paths_to_check = [
        Path.cwd() / ".claude" / "skills" / name / "SKILL.md",
        Path.home() / ".claude" / "skills" / name / "SKILL.md",
    ]

    for path in paths_to_check:
        if path.exists():
            return parse_skill(path.read_text(), name)

    searched = "\n  ".join(str(p) for p in paths_to_check)
    raise FileNotFoundError(f"Skill '{name}' not found. Searched:\n  {searched}")


def list_skills() -> list[dict[str, Any]]:
    all_paths = [
        Path.cwd() / ".claude" / "skills",
        Path.home() / ".claude" / "skills",
    ]

    skills = []
    seen: set[str] = set()

    for base_path in all_paths:
        if not base_path.exists():
            continue
        for skill_dir in base_path.iterdir():
            if skill_dir.is_dir():
                skill_file = skill_dir / "SKILL.md"
                if skill_file.exists() and skill_dir.name not in seen:
                    seen.add(skill_dir.name)
                    try:
                        skill = parse_skill(skill_file.read_text(), skill_dir.name)
                        skills.append({
                            "name": skill.name,
                            "description": skill.description,
                            "inputs": list(skill.inputs.keys()),
                        })
                    except Exception:
                        pass

    return skills


# === Core ===


class SkillRunner:
    """Executes skills via Claude Agent SDK (uses subscription auth)."""

    def __init__(
        self,
        model: str = "claude-sonnet-4-20250514",
        max_turns: int = 1,
    ):
        self.model = model
        self.max_turns = max_turns

    def gather_input(self, command: str) -> str:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode != 0 and result.stderr:
            raise RuntimeError(f"Command failed: {command}\n{result.stderr}")
        return result.stdout

    def resolve_inputs(self, skill: Skill, provided: dict[str, str]) -> dict[str, str]:
        resolved = {}
        for name, input_def in skill.inputs.items():
            if name in provided:
                resolved[name] = provided[name]
            elif input_def.command:
                resolved[name] = self.gather_input(input_def.command)
            elif input_def.required:
                raise ValueError(f"Missing required input '{name}'")
        return resolved

    async def _query(self, prompt: str) -> str:
        """Run a query via Claude Agent SDK."""
        options = ClaudeAgentOptions(
            model=self.model,
            max_turns=self.max_turns,
        )

        result_parts = []
        async for message in query(prompt=prompt, options=options):
            if hasattr(message, "content"):
                result_parts.append(message.content)

        return "".join(result_parts).strip()

    def run(self, skill_name: str, inputs: dict[str, str] | None = None) -> str:
        """Run a skill by name using Claude Code SDK."""
        skill = load_skill(skill_name)
        provided = inputs or {}
        resolved = self.resolve_inputs(skill, provided)
        prompt = skill.render_prompt(resolved)

        return asyncio.run(self._query(prompt))


# === MCP Server ===

server = Server("skill-runner")
runner = SkillRunner()


@server.list_tools()
async def handle_list_tools() -> list[Tool]:
    return [
        Tool(
            name="run_skill",
            description="Run a Claude skill by name with optional inputs",
            inputSchema={
                "type": "object",
                "properties": {
                    "skill_name": {
                        "type": "string",
                        "description": "Name of the skill to run",
                    },
                    "inputs": {
                        "type": "object",
                        "description": "Input values as key-value pairs",
                        "additionalProperties": {"type": "string"},
                    },
                },
                "required": ["skill_name"],
            },
        ),
        Tool(
            name="list_skills",
            description="List all available skills",
            inputSchema={"type": "object", "properties": {}},
        ),
        Tool(
            name="show_skill",
            description="Show details about a specific skill",
            inputSchema={
                "type": "object",
                "properties": {
                    "skill_name": {
                        "type": "string",
                        "description": "Name of the skill",
                    },
                },
                "required": ["skill_name"],
            },
        ),
    ]


@server.call_tool()
async def handle_call_tool(name: str, arguments: dict) -> list[TextContent]:
    if name == "run_skill":
        try:
            result = runner.run(
                arguments["skill_name"],
                inputs=arguments.get("inputs", {}),
            )
            return [TextContent(type="text", text=result)]
        except Exception as e:
            return [TextContent(type="text", text=f"Error: {e}")]

    elif name == "list_skills":
        skills = list_skills()
        if not skills:
            return [TextContent(type="text", text="No skills found.")]

        lines = ["Available skills:", ""]
        for skill in skills:
            inputs_str = f" (inputs: {', '.join(skill['inputs'])})" if skill["inputs"] else ""
            lines.append(f"- {skill['name']}: {skill['description']}{inputs_str}")
        return [TextContent(type="text", text="\n".join(lines))]

    elif name == "show_skill":
        try:
            skill = load_skill(arguments["skill_name"])
            lines = [
                f"Skill: {skill.name}",
                f"Description: {skill.description}",
                "",
                "Inputs:",
            ]
            for inp_name, inp_def in skill.inputs.items():
                cmd = f" (auto: {inp_def.command})" if inp_def.command else ""
                req = "required" if inp_def.required else "optional"
                lines.append(f"  - {inp_name} [{req}]{cmd}: {inp_def.description}")
            lines.append(f"\nOutput format: {skill.output.format}")
            return [TextContent(type="text", text="\n".join(lines))]
        except Exception as e:
            return [TextContent(type="text", text=f"Error: {e}")]

    return [TextContent(type="text", text=f"Unknown tool: {name}")]


async def main() -> None:
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())


if __name__ == "__main__":
    asyncio.run(main())
